# Javascript 인터뷰 핸드북

## 호이스팅

클래스 기반 객체지향은 객체를 추상적이고 본질적인 클래스로 분류하여 속성과 연산을 기반으로 일반화합니다. 반면, 프로토타입 기반 객체지향은 어휘의 본질적인 측면은 없고 상황과 맥락에 따라 의미를 결정합니다. 유사성을 기반으로 가장 전형적인 원형 객체를 정의하고 객체들은 원형을 기반으로 차이점을 반영하여 확장됩니다.

프로토타입 기반 객체지향 언어인 JavaScript(이하 JS)는 실행 컨텍스트에 있는 모든 선언들을 참고하여 어휘의 의미를 정의합니다. 식별자는 선언 단계와 초기화 단계 그리고 할당 단계로 나누어져 있으며, 실행 컨텍스트를 생성할 때 `Lexical Environment`의 `Environment Record`에 변수를 수집하는 선언 단계가 코드 실행 전에 이루어지기 때문에 `Lexical Scope`의 최상단으로 끌어올려지는 것처럼 동작합니다.

`var`은 선언과 초기화가 동시에 이루어져 `undefined`가 할당되지만, `let`과 `const`는 그렇지 않습니다. 따라서 초기화 전에 변수를 사용하면 `ReferenceError`가 발생합니다.

`function` 키워드를 통한 함수 선언은 함수 객체 전체가 호이스팅되지만, 함수를 변수에 할당하는 함수 표현식 방식은 변수 선언만 호이스팅됩니다. 따라서 함수 선언문은 함수를 선언하기 전에 호출해도 문제가 없지만, 함수 표현식은 그렇지 않습니다.

`class` 키워드를 통한 클래스 선언은 호이스팅되지만 초기화되지 않은 `TDZ` 상태를 유지합니다. 반면, 클래스 표현식은 함수 표현식처럼 호이스팅되지 않습니다.

## this

어휘의 의미는 어휘가 속한 문맥에 따라 달라집니다. 문맥에는 그 어휘를 사용하는 주체가 포함되어 있으며, 이 발화 주체는 this로 표현됩니다. 전역 영역에 있는 함수를 호출할 때는 일반적으로 글로벌 객체(브라우저에서는 window)를 가리키며(strict mode일 경우에는 undefined), 객체 안에 속한 메서드를 호출할 때는 해당 객체를 나타냅니다. 생성자가 호출될 경우에는 생성 결과로 응답되는 객체를 나타냅니다.

## 클로저

클로저는 주변 문맥과 그에 대한 참조를 가지고 있는 함수의 조합을 나타냅니다. 즉, 클로저는 내부 함수에서 외부 함수의 스코프에 대한 접근을 제공합니다. 

내부 함수의 실행 컨텍스트가 생성될 때, `Lexical Environment`의 `Outer Environment Reference`에는 내부 함수가 선언될 당시의 외부 함수의 `Lexical Environment`를 참조합니다. 내부 함수에선 `Outer Environment Reference`를 통해 상위 `Lexical Environment` 에 접근하여 외부 변수를 참조할 수 있습니다. 내부 함수에서 `Lexical Environment`를 참조하고 있어 외부 함수가 종료되어 콜 스택에서 실행 컨텍스트가 제거된 이후에도 `GC`에 의해 수집되지 않고 접근할 수 있습니다.

## 실행 컨텍스트

실행 컨텍스트(Execution Context)는 코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 실제로 관리하는 객체입니다. 

식별자와 스코프는 실행 컨텍스트의 `Lexical Environment`에서 관리되며, 코드 실행 순서는 실행 컨텍스트 스택, 즉 콜 스택에서 관리됩니다. 실행 컨텍스트는 `Lexical Environment`, `Variable Environment` 등으로 구성되며, `Variable Environment`는 초기 상태를 기억하고 있고 `Lexical Environment`는 최신 상태를 저장하고 있습니다. 

`Variable Environment`는 최초 실행 시에 설정되며 `Lexical Environment`가 그 값을 복사해서 관리합니다. `Lexical Environment`의 `Environment Record`는 현재 컨텍스트와 관련된 식별자와 식별자에 바인딩된 값을 관리하며, `Outer Environment Reference`에서 상위 컨텍스트에 대한 참조를 관리합니다.
